name: Whitelist SSH
description: Open SSH for the current GitHub Actions runner IP on the DigitalOcean firewall

inputs:
  do_token:
    description: DigitalOcean API token
    required: true
  stack_name:
    description: Stack name to locate the firewall
    required: true

runs:
  using: composite
  steps:
    - name: Open SSH for runner IP
      timeout-minutes: 10
      shell: bash
      env:
        DO_TOKEN: ${{ inputs.do_token }}
      run: |
        set -euo pipefail

        if [ -z "$DO_TOKEN" ]; then
          echo "::warning::No DigitalOcean token provided, skipping SSH whitelist"
          exit 0
        fi

        STACK="${{ inputs.stack_name }}"
        API="https://api.digitalocean.com/v2"
        AUTH="Authorization: Bearer $DO_TOKEN"

        # Get firewall ID by name
        FIREWALLS=$(curl -sf "$API/firewalls?per_page=200" -H "$AUTH")
        FW_ID=$(echo "$FIREWALLS" | jq -r --arg name "${STACK}-firewall" '.firewalls[] | select(.name == $name) | .id')

        if [ -z "$FW_ID" ]; then
          echo "::error::Firewall ${STACK}-firewall not found"
          exit 1
        fi
        echo "Firewall ID: $FW_ID"

        # Get runner IP and current firewall config in parallel
        curl -sf https://api.ipify.org > /tmp/runner_ip.txt &
        IP_PID=$!
        curl -sf "$API/firewalls/$FW_ID" -H "$AUTH" > /tmp/fw_current.json &
        FW_PID=$!
        wait $IP_PID $FW_PID

        RUNNER_IP=$(cat /tmp/runner_ip.txt)
        DROPLET_IDS=$(jq '.firewall.droplet_ids' /tmp/fw_current.json)
        CURRENT_INBOUND=$(jq '.firewall.inbound_rules' /tmp/fw_current.json)
        CURRENT_OUTBOUND=$(jq '.firewall.outbound_rules' /tmp/fw_current.json)
        echo "Runner IP: $RUNNER_IP"

        # Remove any existing SSH rule and add new one with runner IP
        NEW_INBOUND=$(echo "$CURRENT_INBOUND" | jq --arg runner_ip "$RUNNER_IP" '
          [.[] | select(.ports != "22")] +
          [{protocol: "tcp", ports: "22", sources: {addresses: [$runner_ip + "/32"]}}]
        ')

        # Update firewall
        PAYLOAD=$(jq -n \
          --arg name "${STACK}-firewall" \
          --argjson droplet_ids "$DROPLET_IDS" \
          --argjson inbound "$NEW_INBOUND" \
          --argjson outbound "$CURRENT_OUTBOUND" \
          '{name: $name, droplet_ids: $droplet_ids, inbound_rules: $inbound, outbound_rules: $outbound}')

        curl -sf -X PUT "$API/firewalls/$FW_ID" \
          -H "$AUTH" \
          -H "Content-Type: application/json" \
          -d "$PAYLOAD" > /dev/null

        # Verify the rule was applied
        for i in $(seq 1 10); do
          VERIFY=$(curl -sf "$API/firewalls/$FW_ID" -H "$AUTH")
          if echo "$VERIFY" | jq -e --arg ip "$RUNNER_IP/32" \
            '.firewall.inbound_rules[] | select(.ports == "22") | .sources.addresses[] | select(. == $ip)' > /dev/null 2>&1; then
            echo "SSH rule verified in firewall"
            break
          fi
          if [ "$i" -eq 10 ]; then
            echo "::error::SSH rule not found in firewall after 10 verification attempts"
            exit 1
          fi
          echo "Waiting for firewall rule to propagate (attempt $i/10)..."
          sleep 3
        done

        # Brief delay for network-level propagation
        echo "Waiting for firewall propagation..."
        sleep 10

        echo "SSH opened for runner IP: $RUNNER_IP"
