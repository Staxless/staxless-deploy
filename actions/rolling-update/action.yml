name: Rolling Update
description: Perform zero-downtime rolling updates with automatic rollback and convergence verification

inputs:
  manager_ip:
    description: Manager node public IP
    required: true
  services:
    description: Comma-separated list of services to update, or "all"
    required: false
    default: all
  stack_name:
    description: Docker stack name
    required: false
    default: staxless
  convergence_timeout:
    description: Max seconds to wait for each service to converge
    required: false
    default: '120'

runs:
  using: composite
  steps:
    - name: Rolling update services
      shell: bash
      run: |
        MANAGER_IP="${{ inputs.manager_ip }}"
        SERVICES="${{ inputs.services }}"
        STACK="${{ inputs.stack_name }}"
        MAX_WAIT="${{ inputs.convergence_timeout }}"

        echo "Rolling update for: $SERVICES"

        # Third-party infra services — skip on "all", include when kafka is explicitly requested
        INFRA_SKIP="zookeeper kafka-service kafka-setup"

        if [ "$SERVICES" = "all" ]; then
          SERVICE_LIST=""
          ALL_SERVICES=$(ssh root@"$MANAGER_IP" "docker service ls --format '{{.Name}}' | grep '^${STACK}_'")
          for service in $ALL_SERVICES; do
            SHORT_NAME="${service#${STACK}_}"
            SKIP=false
            for infra in $INFRA_SKIP; do
              if [ "$SHORT_NAME" = "$infra" ]; then
                SKIP=true
                break
              fi
            done
            if [ "$SKIP" = "true" ]; then
              echo "SKIP: $service (infra service, not included in 'all')"
            else
              SERVICE_LIST="$SERVICE_LIST $service"
            fi
          done
        else
          SERVICE_LIST=""
          INCLUDE_KAFKA_INFRA=false
          IFS=',' read -ra SERVICE_NAMES <<< "$SERVICES"

          # If kafka is explicitly requested, include all three kafka/zookeeper services
          for service in "${SERVICE_NAMES[@]}"; do
            service=$(echo "$service" | xargs)
            if [ "$service" = "kafka-service" ] || [ "$service" = "kafka" ]; then
              INCLUDE_KAFKA_INFRA=true
            fi
          done

          for service in "${SERVICE_NAMES[@]}"; do
            service=$(echo "$service" | xargs)
            SERVICE_LIST="$SERVICE_LIST ${STACK}_${service}"
          done

          if [ "$INCLUDE_KAFKA_INFRA" = "true" ]; then
            for infra in $INFRA_SKIP; do
              if ! echo "$SERVICE_LIST" | grep -qw "${STACK}_${infra}"; then
                SERVICE_LIST="$SERVICE_LIST ${STACK}_${infra}"
              fi
            done
            echo "Kafka explicitly requested — including zookeeper, kafka-service, kafka-setup"
          fi
        fi

        # --- Function to update a single service ---
        update_service() {
          local service="$1"
          local log_file="$2"

          {
            echo "=== Updating: $service ==="

            CURRENT_IMAGE=$(ssh root@"$MANAGER_IP" "docker service inspect $service --format '{{.Spec.TaskTemplate.ContainerSpec.Image}}'")
            IMAGE_BASE=$(echo "$CURRENT_IMAGE" | cut -d: -f1)
            NEW_IMAGE="${IMAGE_BASE}:latest"

            # Get the digest of what's currently running (image@sha256:...)
            CURRENT_DIGEST=$(echo "$CURRENT_IMAGE" | grep -o 'sha256:[a-f0-9]*' || echo "")

            # Get the digest of the latest tag in the registry
            LATEST_DIGEST=$(ssh root@"$MANAGER_IP" "docker pull $NEW_IMAGE 2>/dev/null | grep 'Digest:' | awk '{print \$2}'" || echo "")

            echo "Current: $CURRENT_IMAGE"
            echo "Target:  $NEW_IMAGE"
            echo "Current digest: ${CURRENT_DIGEST:-none}"
            echo "Latest digest:  ${LATEST_DIGEST:-none}"

            # Skip if digests match — no actual change
            if [ -n "$CURRENT_DIGEST" ] && [ -n "$LATEST_DIGEST" ] && [ "$CURRENT_DIGEST" = "$LATEST_DIGEST" ]; then
              echo "SKIP: $service already running latest image — no update needed"
              exit 0
            fi

            # Use digest-pinned image so Docker sees an actual spec change
            FORCE_FLAG=""
            if [ -n "$LATEST_DIGEST" ]; then
              UPDATE_IMAGE="${IMAGE_BASE}@${LATEST_DIGEST}"
            else
              UPDATE_IMAGE="$NEW_IMAGE"
              FORCE_FLAG="--force"
            fi

            ssh root@"$MANAGER_IP" "docker service update \
              --with-registry-auth \
              --image $UPDATE_IMAGE \
              --update-parallelism 1 \
              --update-delay 10s \
              --update-failure-action rollback \
              --update-monitor 30s \
              $FORCE_FLAG \
              $service"

            # Wait for convergence
            ELAPSED=0
            INTERVAL=10
            CONVERGED=false

            while [ "$ELAPSED" -lt "$MAX_WAIT" ]; do
              sleep "$INTERVAL"
              ELAPSED=$((ELAPSED + INTERVAL))

              STATE=$(ssh root@"$MANAGER_IP" "docker service inspect $service --format '{{if .UpdateStatus}}{{.UpdateStatus.State}}{{else}}unknown{{end}}'")

              if [ "$STATE" = "completed" ]; then
                echo "$service converged on $NEW_IMAGE (${ELAPSED}s)"
                CONVERGED=true
                break
              elif [ "$STATE" = "unknown" ]; then
                # No UpdateStatus means stable — update completed or was a no-op
                RUNNING_COUNT=$(ssh root@"$MANAGER_IP" "docker service ps $service --filter desired-state=running -q | wc -l")
                if [ "$RUNNING_COUNT" -gt 0 ]; then
                  echo "$service converged on $NEW_IMAGE (${ELAPSED}s, tasks running)"
                  CONVERGED=true
                  break
                fi
              elif [ "$STATE" = "rollback_completed" ]; then
                echo "FAILED: $service rolled back to previous image"
                exit 1
              fi

              echo "  waiting for $service to converge (${ELAPSED}/${MAX_WAIT}s, state=$STATE)"
            done

            if [ "$CONVERGED" = "false" ]; then
              echo "FAILED: $service did not converge within ${MAX_WAIT}s (state=$STATE)"
              ssh root@"$MANAGER_IP" "docker service ps $service --no-trunc" || true
              exit 1
            fi
          } > "$log_file" 2>&1
        }

        # --- Launch all updates in parallel ---
        PIDS=()
        LOG_FILES=()
        SERVICE_NAMES_ORDERED=()
        TMPDIR=$(mktemp -d)

        for service in $SERVICE_LIST; do
          LOG_FILE="$TMPDIR/${service}.log"
          LOG_FILES+=("$LOG_FILE")
          SERVICE_NAMES_ORDERED+=("$service")
          update_service "$service" "$LOG_FILE" &
          PIDS+=($!)
        done

        echo ""
        echo "Launched ${#PIDS[@]} parallel updates, waiting for completion..."
        echo ""

        # --- Wait for all and collect results ---
        FAILED=0
        FAILED_SERVICES=()
        SKIPPED_SERVICES=()
        OK_SERVICES=()
        for i in "${!PIDS[@]}"; do
          pid="${PIDS[$i]}"
          service="${SERVICE_NAMES_ORDERED[$i]}"
          log_file="${LOG_FILES[$i]}"

          if wait "$pid"; then
            # Check if it was skipped (digest match) vs actually updated
            if grep -q "^SKIP:" "$log_file" 2>/dev/null; then
              echo "--- $service: SKIPPED (unchanged) ---"
              SKIPPED_SERVICES+=("$service")
            else
              echo "--- $service: OK ---"
              OK_SERVICES+=("$service")
            fi
          else
            echo "--- $service: FAILED ---"
            FAILED=1
            FAILED_SERVICES+=("$service")
          fi
          cat "$log_file"
          echo ""
        done

        rm -rf "$TMPDIR"

        # --- Summary ---
        echo ""
        echo "========== ROLLING UPDATE SUMMARY =========="
        echo "  Updated: ${#OK_SERVICES[@]}  — ${OK_SERVICES[*]:-none}"
        echo "  Skipped: ${#SKIPPED_SERVICES[@]}  — ${SKIPPED_SERVICES[*]:-none}"
        echo "  Failed:  ${#FAILED_SERVICES[@]}  — ${FAILED_SERVICES[*]:-none}"
        echo "============================================="

        if [ "$FAILED" -eq 1 ]; then
          echo ""
          echo "FAILED SERVICES: ${FAILED_SERVICES[*]}"
          exit 1
        fi

        # Clean up dangling images left behind by previous deploys
        echo "Pruning dangling images..."
        ssh root@"$MANAGER_IP" "docker image prune -f" || true

        echo ""
        echo "All services updated and converged"
