name: Rolling Update
description: Perform zero-downtime rolling updates with automatic rollback and convergence verification

inputs:
  manager_ip:
    description: Manager node public IP
    required: true
  services:
    description: Comma-separated list of services to update, or "all"
    required: false
    default: all
  stack_name:
    description: Docker stack name
    required: false
    default: staxless
  convergence_timeout:
    description: Max seconds to wait for each service to converge
    required: false
    default: '120'

runs:
  using: composite
  steps:
    - name: Rolling update services
      shell: bash
      run: |
        MANAGER_IP="${{ inputs.manager_ip }}"
        SERVICES="${{ inputs.services }}"
        STACK="${{ inputs.stack_name }}"
        MAX_WAIT="${{ inputs.convergence_timeout }}"

        echo "Rolling update for: $SERVICES"

        if [ "$SERVICES" = "all" ]; then
          SERVICE_LIST=$(ssh root@"$MANAGER_IP" "docker service ls --format '{{.Name}}' | grep '^${STACK}_'")
        else
          SERVICE_LIST=""
          IFS=',' read -ra SERVICE_NAMES <<< "$SERVICES"
          for service in "${SERVICE_NAMES[@]}"; do
            service=$(echo "$service" | xargs)
            SERVICE_LIST="$SERVICE_LIST ${STACK}_${service}"
          done
        fi

        # --- Function to update a single service ---
        update_service() {
          local service="$1"
          local log_file="$2"

          {
            echo "=== Updating: $service ==="

            CURRENT_IMAGE=$(ssh root@"$MANAGER_IP" "docker service inspect $service --format '{{.Spec.TaskTemplate.ContainerSpec.Image}}'")
            IMAGE_BASE=$(echo "$CURRENT_IMAGE" | cut -d: -f1)
            NEW_IMAGE="${IMAGE_BASE}:latest"

            # Get the digest of what's currently running (image@sha256:...)
            CURRENT_DIGEST=$(echo "$CURRENT_IMAGE" | grep -o 'sha256:[a-f0-9]*' || echo "")

            # Get the digest of the latest tag in the registry
            LATEST_DIGEST=$(ssh root@"$MANAGER_IP" "docker pull $NEW_IMAGE 2>/dev/null | grep 'Digest:' | awk '{print \$2}'" || echo "")

            echo "Current: $CURRENT_IMAGE"
            echo "Target:  $NEW_IMAGE"
            echo "Current digest: ${CURRENT_DIGEST:-none}"
            echo "Latest digest:  ${LATEST_DIGEST:-none}"

            # Skip if digests match — no actual change
            if [ -n "$CURRENT_DIGEST" ] && [ -n "$LATEST_DIGEST" ] && [ "$CURRENT_DIGEST" = "$LATEST_DIGEST" ]; then
              echo "SKIP: $service already running latest image — no update needed"
              exit 0
            fi

            ssh root@"$MANAGER_IP" "docker service update \
              --image $NEW_IMAGE \
              --update-parallelism 1 \
              --update-delay 10s \
              --update-failure-action rollback \
              --update-monitor 30s \
              $service"

            # Wait for convergence
            ELAPSED=0
            INTERVAL=10
            CONVERGED=false

            while [ "$ELAPSED" -lt "$MAX_WAIT" ]; do
              sleep "$INTERVAL"
              ELAPSED=$((ELAPSED + INTERVAL))

              STATE=$(ssh root@"$MANAGER_IP" "docker service inspect $service --format '{{if .UpdateStatus}}{{.UpdateStatus.State}}{{else}}unknown{{end}}'")

              if [ "$STATE" = "completed" ] || [ "$STATE" = "unknown" ]; then
                RUNNING_IMAGES=$(ssh root@"$MANAGER_IP" "docker service ps $service --filter desired-state=running --format '{{.Image}}' | sort -u")

                if echo "$RUNNING_IMAGES" | grep -q "$IMAGE_BASE"; then
                  echo "$service converged on $NEW_IMAGE (${ELAPSED}s)"
                  CONVERGED=true
                  break
                fi
              elif [ "$STATE" = "rollback_completed" ]; then
                echo "FAILED: $service rolled back to previous image"
                exit 1
              fi

              echo "  waiting for $service to converge (${ELAPSED}/${MAX_WAIT}s, state=$STATE)"
            done

            if [ "$CONVERGED" = "false" ]; then
              echo "FAILED: $service did not converge within ${MAX_WAIT}s (state=$STATE)"
              ssh root@"$MANAGER_IP" "docker service ps $service --no-trunc" || true
              exit 1
            fi
          } > "$log_file" 2>&1
        }

        # --- Launch all updates in parallel ---
        PIDS=()
        LOG_FILES=()
        SERVICE_NAMES_ORDERED=()
        TMPDIR=$(mktemp -d)

        for service in $SERVICE_LIST; do
          LOG_FILE="$TMPDIR/${service}.log"
          LOG_FILES+=("$LOG_FILE")
          SERVICE_NAMES_ORDERED+=("$service")
          update_service "$service" "$LOG_FILE" &
          PIDS+=($!)
        done

        echo ""
        echo "Launched ${#PIDS[@]} parallel updates, waiting for completion..."
        echo ""

        # --- Wait for all and collect results ---
        FAILED=0
        for i in "${!PIDS[@]}"; do
          pid="${PIDS[$i]}"
          service="${SERVICE_NAMES_ORDERED[$i]}"
          log_file="${LOG_FILES[$i]}"

          if wait "$pid"; then
            echo "--- $service: OK ---"
          else
            echo "--- $service: FAILED ---"
            FAILED=1
          fi
          cat "$log_file"
          echo ""
        done

        rm -rf "$TMPDIR"

        echo ""
        if [ "$FAILED" -eq 1 ]; then
          echo "One or more services failed to update"
          exit 1
        fi

        echo "All services updated and converged"
