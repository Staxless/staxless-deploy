name: Rolling Update
description: Perform zero-downtime rolling updates with automatic rollback and convergence verification

inputs:
  manager_ip:
    description: Manager node public IP
    required: true
  services:
    description: Comma-separated list of services to update, or "all"
    required: false
    default: all
  stack_name:
    description: Docker stack name
    required: false
    default: staxless
  convergence_timeout:
    description: Max seconds to wait for each service to converge
    required: false
    default: '120'

runs:
  using: composite
  steps:
    - name: Rolling update services
      shell: bash
      run: |
        MANAGER_IP="${{ inputs.manager_ip }}"
        SERVICES="${{ inputs.services }}"
        STACK="${{ inputs.stack_name }}"
        MAX_WAIT="${{ inputs.convergence_timeout }}"

        echo "Rolling update for: $SERVICES"

        if [ "$SERVICES" = "all" ]; then
          SERVICE_LIST=$(ssh root@"$MANAGER_IP" "docker service ls --format '{{.Name}}' | grep '^${STACK}_'")
        else
          SERVICE_LIST=""
          IFS=',' read -ra SERVICE_NAMES <<< "$SERVICES"
          for service in "${SERVICE_NAMES[@]}"; do
            service=$(echo "$service" | xargs)
            SERVICE_LIST="$SERVICE_LIST ${STACK}_${service}"
          done
        fi

        FAILED=0
        for service in $SERVICE_LIST; do
          echo ""
          echo "=== Updating: $service ==="

          CURRENT_IMAGE=$(ssh root@"$MANAGER_IP" "docker service inspect $service --format '{{.Spec.TaskTemplate.ContainerSpec.Image}}'")
          IMAGE_BASE=$(echo "$CURRENT_IMAGE" | cut -d: -f1)
          NEW_IMAGE="${IMAGE_BASE}:latest"

          echo "Current: $CURRENT_IMAGE"
          echo "Target:  $NEW_IMAGE"

          ssh root@"$MANAGER_IP" "docker service update \
            --image $NEW_IMAGE \
            --update-parallelism 1 \
            --update-delay 10s \
            --update-failure-action rollback \
            --update-monitor 30s \
            $service"

          # Wait for convergence — verify tasks are running the new image
          ELAPSED=0
          INTERVAL=10
          CONVERGED=false

          while [ "$ELAPSED" -lt "$MAX_WAIT" ]; do
            sleep "$INTERVAL"
            ELAPSED=$((ELAPSED + INTERVAL))

            STATE=$(ssh root@"$MANAGER_IP" "docker service inspect $service --format '{{if .UpdateStatus}}{{.UpdateStatus.State}}{{else}}unknown{{end}}'")

            if [ "$STATE" = "completed" ] || [ "$STATE" = "unknown" ]; then
              # Verify running tasks match the desired image
              RUNNING_IMAGES=$(ssh root@"$MANAGER_IP" "docker service ps $service --filter desired-state=running --format '{{.Image}}' | sort -u")

              if echo "$RUNNING_IMAGES" | grep -q "$IMAGE_BASE"; then
                if [ "$STATE" = "unknown" ]; then
                  echo "$service already running target image — no update needed (${ELAPSED}s)"
                else
                  echo "$service converged on $NEW_IMAGE (${ELAPSED}s)"
                fi
                CONVERGED=true
                break
              fi
            elif [ "$STATE" = "rollback_completed" ]; then
              echo "FAILED: $service rolled back to previous image"
              FAILED=1
              CONVERGED=true
              break
            fi

            echo "  waiting for $service to converge (${ELAPSED}/${MAX_WAIT}s, state=$STATE)"
          done

          if [ "$CONVERGED" = "false" ]; then
            echo "FAILED: $service did not converge within ${MAX_WAIT}s (state=$STATE)"
            ssh root@"$MANAGER_IP" "docker service ps $service --no-trunc" || true
            FAILED=1
          fi
        done

        echo ""
        if [ "$FAILED" -eq 1 ]; then
          echo "One or more services failed to update"
          exit 1
        fi

        echo "All services updated and converged"
