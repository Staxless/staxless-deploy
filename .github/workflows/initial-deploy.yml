name: Initial Deploy

on:
  workflow_call:
    inputs:
      cloud_provider:
        type: string
        default: digitalocean
      region:
        type: string
        default: nyc3
      manager_size:
        type: string
        default: s-2vcpu-4gb
      worker_size:
        type: string
        default: s-2vcpu-4gb
      worker_count:
        type: string
        default: '2'
      stack_name:
        type: string
        default: ''
      compose_file:
        type: string
        default: docker/compose/docker-compose.prod.yml
      bake_file:
        type: string
        default: docker/docker-bake.hcl
      registry_type:
        type: string
        default: ghcr
      domain:
        type: string
        required: true
      mongodb_setup:
        type: boolean
        default: true
      state_bucket:
        type: string
        default: staxless-terraform-state
      state_key:
        type: string
        default: ''
    secrets:
      SSH_PRIVATE_KEY:
        required: true
      DIGITALOCEAN_TOKEN:
        required: true
      DO_SPACES_ACCESS_KEY:
        required: true
      DO_SPACES_SECRET_KEY:
        required: true
      SSH_FINGERPRINT:
        required: true
      MONGODB_ATLAS_PUBLIC_KEY:
        required: false
      MONGODB_ATLAS_PRIVATE_KEY:
        required: false
      MONGODB_ATLAS_PROJECT_ID:
        required: false
      DATABASE_URL:
        required: false
      GOOGLE_CLIENT_ID:
        required: false
      GOOGLE_CLIENT_SECRET:
        required: false
      GOOGLE_REDIRECT_URI:
        required: false
      GH_OAUTH_CLIENT_ID:
        required: false
      GH_OAUTH_CLIENT_SECRET:
        required: false
      STRIPE_PRIVATE_KEY:
        required: false
      STRIPE_WEBHOOK_SECRET:
        required: false
      MAILGUN_API_KEY:
        required: false
      CLOUDFLARE_TUNNEL_TOKEN:
        required: false
      GHCR_TOKEN:
        required: false

jobs:
  # ── Phase 1: Provision infrastructure ──────────────────────────
  provision:
    name: Provision Infrastructure
    runs-on: ubuntu-latest
    timeout-minutes: 30
    outputs:
      manager_ip: ${{ steps.infra.outputs.manager_ip }}
      worker_ips: ${{ steps.infra.outputs.worker_ips }}
      all_node_ips: ${{ steps.infra.outputs.all_node_ips }}
      stack_name: ${{ steps.config.outputs.stack_name }}
      compose_file: ${{ steps.config.outputs.compose_file }}
      bake_file: ${{ steps.config.outputs.bake_file }}
    steps:
      - name: Checkout consumer repo
        uses: actions/checkout@v4

      - name: Checkout staxless-deploy
        uses: actions/checkout@v4
        with:
          repository: staxless/staxless-deploy
          path: .staxless-deploy

      - name: Resolve Config
        id: config
        uses: ./.staxless-deploy/actions/resolve-config
        with:
          stack_name: ${{ inputs.stack_name }}
          region: ${{ inputs.region }}
          manager_size: ${{ inputs.manager_size }}
          worker_size: ${{ inputs.worker_size }}
          worker_count: ${{ inputs.worker_count }}
          compose_file: ${{ inputs.compose_file }}
          bake_file: ${{ inputs.bake_file }}

      - name: Setup SSH
        uses: ./.staxless-deploy/actions/setup-ssh
        with:
          ssh_private_key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Setup Tools
        uses: ./.staxless-deploy/actions/setup-tools
        with:
          do_token: ${{ secrets.DIGITALOCEAN_TOKEN }}
          cloud_provider: ${{ inputs.cloud_provider }}

      - name: Provision Infrastructure
        id: infra
        uses: ./.staxless-deploy/actions/terraform-provision
        with:
          cloud_provider: ${{ inputs.cloud_provider }}
          do_token: ${{ secrets.DIGITALOCEAN_TOKEN }}
          do_spaces_access_key: ${{ secrets.DO_SPACES_ACCESS_KEY }}
          do_spaces_secret_key: ${{ secrets.DO_SPACES_SECRET_KEY }}
          ssh_fingerprint: ${{ secrets.SSH_FINGERPRINT }}
          domain: ${{ inputs.domain }}
          stack_name: ${{ steps.config.outputs.stack_name }}
          region: ${{ steps.config.outputs.region }}
          manager_size: ${{ steps.config.outputs.manager_size }}
          worker_size: ${{ steps.config.outputs.worker_size }}
          worker_count: ${{ steps.config.outputs.worker_count }}
          state_bucket: ${{ inputs.state_bucket }}
          state_key: ${{ inputs.state_key || format('{0}/terraform.tfstate', steps.config.outputs.stack_name) }}

  # ── Phase 1b: Setup MongoDB Atlas (parallel with provision) ───
  setup-mongodb:
    name: Setup MongoDB Atlas
    if: inputs.mongodb_setup
    runs-on: ubuntu-latest
    timeout-minutes: 20
    outputs:
      database_url: ${{ steps.mongodb_out.outputs.database_url }}
    steps:
      - name: Checkout staxless-deploy
        uses: actions/checkout@v4
        with:
          repository: staxless/staxless-deploy
          path: .staxless-deploy

      - name: Setup MongoDB Atlas
        id: mongodb_out
        env:
          MONGODB_ATLAS_PUBLIC_KEY: ${{ secrets.MONGODB_ATLAS_PUBLIC_KEY }}
          MONGODB_ATLAS_PRIVATE_KEY: ${{ secrets.MONGODB_ATLAS_PRIVATE_KEY }}
          MONGODB_ATLAS_PROJECT_ID: ${{ secrets.MONGODB_ATLAS_PROJECT_ID }}
        run: |
          bash .staxless-deploy/scripts/infrastructure/setup-mongodb-atlas.sh

          # Script writes DATABASE_URL to GITHUB_ENV (available next step),
          # but we need it now — read it back from the file
          source "$GITHUB_ENV"

          if [ -n "$DATABASE_URL" ]; then
            echo "::add-mask::$DATABASE_URL"
            {
              echo "database_url<<MONGOEOF"
              echo "$DATABASE_URL"
              echo "MONGOEOF"
            } >> "$GITHUB_OUTPUT"
            echo "DATABASE_URL output set"
          else
            echo "::error::setup-mongodb-atlas.sh did not set DATABASE_URL"
            exit 1
          fi

  # ── Phase 2: Build images + Setup swarm (parallel) ────────────
  build-images:
    name: Build Images
    needs: provision
    runs-on: ubuntu-latest
    timeout-minutes: 20
    permissions:
      contents: read
      packages: write
    steps:
      - name: Checkout consumer repo
        uses: actions/checkout@v4

      - name: Checkout staxless-deploy
        uses: actions/checkout@v4
        with:
          repository: staxless/staxless-deploy
          path: .staxless-deploy

      - name: Registry Login
        uses: ./.staxless-deploy/actions/registry-login
        with:
          registry_type: ${{ inputs.registry_type }}
          github_token: ${{ github.token }}
          ghcr_token: ${{ secrets.GHCR_TOKEN }}
          github_actor: ${{ github.actor }}
          do_token: ${{ secrets.DIGITALOCEAN_TOKEN }}

      - name: Build Images
        uses: ./.staxless-deploy/actions/build-images
        with:
          services: all
          bake_file: ${{ needs.provision.outputs.bake_file }}

  setup-swarm:
    name: Setup Swarm
    needs: provision
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - name: Checkout consumer repo
        uses: actions/checkout@v4

      - name: Checkout staxless-deploy
        uses: actions/checkout@v4
        with:
          repository: staxless/staxless-deploy
          path: .staxless-deploy

      - name: Setup SSH
        uses: ./.staxless-deploy/actions/setup-ssh
        with:
          ssh_private_key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Whitelist SSH
        uses: ./.staxless-deploy/actions/whitelist-ssh
        with:
          do_token: ${{ secrets.DIGITALOCEAN_TOKEN }}
          stack_name: ${{ needs.provision.outputs.stack_name }}

      - name: Initialize Swarm
        uses: ./.staxless-deploy/actions/init-swarm
        with:
          manager_ip: ${{ needs.provision.outputs.manager_ip }}
          worker_ips: ${{ needs.provision.outputs.worker_ips }}

      - name: Detect required secrets from compose
        id: detect-secrets
        shell: bash
        run: |
          COMPOSE_FILE="${{ needs.provision.outputs.compose_file }}"
          if [ ! -f "$COMPOSE_FILE" ]; then
            echo "Compose file not found: $COMPOSE_FILE"
            echo "secrets_json={}" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Extract top-level secret names from the compose file
          SECRET_NAMES=$(python3 -c "
          import yaml, json, sys
          with open('$COMPOSE_FILE') as f:
              compose = yaml.safe_load(f)
          secrets = list(compose.get('secrets', {}).keys())
          print(json.dumps(secrets))
          ")

          echo "Detected secrets: $SECRET_NAMES"
          echo "secret_names=$SECRET_NAMES" >> "$GITHUB_OUTPUT"

      - name: Create Secrets
        shell: bash
        env:
          MANAGER_IP: ${{ needs.provision.outputs.manager_ip }}
          STACK_NAME: ${{ needs.provision.outputs.stack_name }}
          SECRET_NAMES: ${{ steps.detect-secrets.outputs.secret_names }}
          # All available secrets as env vars for dynamic lookup
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          DATABASE_NAME: ${{ needs.provision.outputs.stack_name }}
          GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET: ${{ secrets.GOOGLE_CLIENT_SECRET }}
          GOOGLE_REDIRECT_URI: ${{ secrets.GOOGLE_REDIRECT_URI }}
          GH_OAUTH_CLIENT_ID: ${{ secrets.GH_OAUTH_CLIENT_ID }}
          GH_OAUTH_CLIENT_SECRET: ${{ secrets.GH_OAUTH_CLIENT_SECRET }}
          STRIPE_PRIVATE_KEY: ${{ secrets.STRIPE_PRIVATE_KEY }}
          STRIPE_WEBHOOK_SECRET: ${{ secrets.STRIPE_WEBHOOK_SECRET }}
          MAILGUN_API_KEY: ${{ secrets.MAILGUN_API_KEY }}
          CLOUDFLARE_TUNNEL_TOKEN: ${{ secrets.CLOUDFLARE_TUNNEL_TOKEN }}
        run: |
          echo "Creating Docker secrets..."

          # Parse the detected secret names and create only those
          echo "$SECRET_NAMES" | jq -r '.[]' | while read -r SECRET_NAME; do
            SECRET_VALUE="${!SECRET_NAME}"
            if [ -n "$SECRET_VALUE" ]; then
              echo "Creating secret: $SECRET_NAME"
              printf '%s' "$SECRET_VALUE" | ssh root@"$MANAGER_IP" "docker secret create $SECRET_NAME - 2>/dev/null" || echo "$SECRET_NAME already exists"
            else
              echo "Skipping $SECRET_NAME (not set)"
            fi
          done

          echo "Secrets created:"
          ssh root@"$MANAGER_IP" "docker secret ls"

  # ── Phase 2b: Finalize MongoDB (whitelist IPs + create DB secret) ──
  finalize-mongodb:
    name: Finalize MongoDB
    needs: [provision, setup-mongodb, setup-swarm]
    if: inputs.mongodb_setup && needs.setup-mongodb.result == 'success' && !cancelled()
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - name: Validate MongoDB output
        run: |
          DATABASE_URL="${{ needs.setup-mongodb.outputs.database_url }}"
          if [ -z "$DATABASE_URL" ]; then
            echo "::error::DATABASE_URL is empty — setup-mongodb did not produce a connection string"
            exit 1
          fi
          echo "DATABASE_URL received from setup-mongodb"

      - name: Checkout staxless-deploy
        uses: actions/checkout@v4
        with:
          repository: staxless/staxless-deploy
          path: .staxless-deploy

      - name: Setup SSH
        uses: ./.staxless-deploy/actions/setup-ssh
        with:
          ssh_private_key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Whitelist SSH
        uses: ./.staxless-deploy/actions/whitelist-ssh
        with:
          do_token: ${{ secrets.DIGITALOCEAN_TOKEN }}
          stack_name: ${{ needs.provision.outputs.stack_name }}

      - name: Whitelist IPs in MongoDB Atlas
        env:
          MONGODB_ATLAS_PUBLIC_KEY: ${{ secrets.MONGODB_ATLAS_PUBLIC_KEY }}
          MONGODB_ATLAS_PRIVATE_KEY: ${{ secrets.MONGODB_ATLAS_PRIVATE_KEY }}
          MONGODB_ATLAS_PROJECT_ID: ${{ secrets.MONGODB_ATLAS_PROJECT_ID }}
          ALL_NODE_IPS: ${{ needs.provision.outputs.all_node_ips }}
        run: bash .staxless-deploy/scripts/infrastructure/whitelist-mongodb-atlas.sh

      - name: Create MongoDB Secrets
        run: |
          DATABASE_URL="${{ needs.setup-mongodb.outputs.database_url }}"
          DATABASE_NAME="${{ needs.provision.outputs.stack_name }}"
          MANAGER_IP="${{ needs.provision.outputs.manager_ip }}"

          upsert_secret() {
            local name="$1" value="$2"
            if [ -z "$value" ]; then
              echo "Warning: $name is empty, skipping"
              return
            fi
            echo "Upserting Docker secret: $name"
            # Remove old secret if it exists (ignore error if it doesn't)
            ssh root@"$MANAGER_IP" "docker secret rm $name 2>/dev/null" || true
            printf '%s' "$value" | ssh root@"$MANAGER_IP" "docker secret create $name -"
          }

          echo "::add-mask::$DATABASE_URL"

          upsert_secret "DATABASE_URL" "$DATABASE_URL"
          upsert_secret "DATABASE_NAME" "$DATABASE_NAME"

          echo "MongoDB secrets created:"
          ssh root@"$MANAGER_IP" "docker secret ls"

  # ── Phase 3: Deploy (waits for build + swarm + mongodb) ────────
  deploy:
    name: Deploy Stack
    needs: [provision, build-images, setup-swarm, finalize-mongodb]
    if: ${{ !cancelled() && needs.provision.result == 'success' && needs.build-images.result == 'success' && needs.setup-swarm.result == 'success' && (needs.finalize-mongodb.result == 'success' || needs.finalize-mongodb.result == 'skipped') }}
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - name: Checkout consumer repo
        uses: actions/checkout@v4

      - name: Checkout staxless-deploy
        uses: actions/checkout@v4
        with:
          repository: staxless/staxless-deploy
          path: .staxless-deploy

      - name: Setup SSH
        uses: ./.staxless-deploy/actions/setup-ssh
        with:
          ssh_private_key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Whitelist SSH
        uses: ./.staxless-deploy/actions/whitelist-ssh
        with:
          do_token: ${{ secrets.DIGITALOCEAN_TOKEN }}
          stack_name: ${{ needs.provision.outputs.stack_name }}

      - name: Deploy Stack
        uses: ./.staxless-deploy/actions/deploy-stack
        with:
          manager_ip: ${{ needs.provision.outputs.manager_ip }}
          compose_file: ${{ needs.provision.outputs.compose_file }}
          stack_name: ${{ needs.provision.outputs.stack_name }}

      - name: Health Check
        uses: ./.staxless-deploy/actions/health-check
        with:
          manager_ip: ${{ needs.provision.outputs.manager_ip }}
          stack_name: ${{ needs.provision.outputs.stack_name }}

  # ── Cleanup: always remove SSH access ─────────────────────────
  cleanup:
    name: Cleanup SSH
    needs: [provision, deploy, finalize-mongodb]
    if: always()
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: Checkout staxless-deploy
        uses: actions/checkout@v4
        with:
          repository: staxless/staxless-deploy
          path: .staxless-deploy

      - name: Remove SSH Whitelist
        uses: ./.staxless-deploy/actions/remove-ssh
        with:
          do_token: ${{ secrets.DIGITALOCEAN_TOKEN }}
          stack_name: ${{ needs.provision.outputs.stack_name }}
